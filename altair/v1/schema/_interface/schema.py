# -*- coding: utf-8 -*-
# Auto-generated by schemapi: do not modify file directly
# - schemapi version: 0.3.0
# - date:    2017-10-17 17:01:03



import traitlets as T
from . import jstraitlets as jst


def _localname(name):
    """Construct an object name relative to the local module"""
    return "{0}.{1}".format(__name__, name)



class AggregateOp(jst.JSONEnum):
    """
    One of ['values', 'count', 'valid', 'missing', 'distinct', 'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', 'argmin', 'argmax']
    """
    values = ['values', 'count', 'valid', 'missing', 'distinct', 'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', 'argmin', 'argmax']
    def __init__(self, **kwargs):
        super(AggregateOp, self).__init__(self.values, **kwargs)


class AreaOverlay(jst.JSONEnum):
    """
    One of ['line', 'linepoint', 'none']
    """
    values = ['line', 'linepoint', 'none']
    def __init__(self, **kwargs):
        super(AreaOverlay, self).__init__(self.values, **kwargs)


class AxisOrient(jst.JSONEnum):
    """
    One of ['top', 'right', 'left', 'bottom']
    """
    values = ['top', 'right', 'left', 'bottom']
    def __init__(self, **kwargs):
        super(AxisOrient, self).__init__(self.values, **kwargs)


class BandSize(jst.JSONEnum):
    """
    One of ['fit']
    """
    values = ['fit']
    def __init__(self, **kwargs):
        super(BandSize, self).__init__(self.values, **kwargs)


class DataFormatType(jst.JSONEnum):
    """
    One of ['json', 'csv', 'tsv', 'topojson']
    """
    values = ['json', 'csv', 'tsv', 'topojson']
    def __init__(self, **kwargs):
        super(DataFormatType, self).__init__(self.values, **kwargs)


class FontStyle(jst.JSONEnum):
    """
    One of ['normal', 'italic']
    """
    values = ['normal', 'italic']
    def __init__(self, **kwargs):
        super(FontStyle, self).__init__(self.values, **kwargs)


class FontWeight(jst.JSONEnum):
    """
    One of ['normal', 'bold']
    """
    values = ['normal', 'bold']
    def __init__(self, **kwargs):
        super(FontWeight, self).__init__(self.values, **kwargs)


class HorizontalAlign(jst.JSONEnum):
    """
    One of ['left', 'right', 'center']
    """
    values = ['left', 'right', 'center']
    def __init__(self, **kwargs):
        super(HorizontalAlign, self).__init__(self.values, **kwargs)


class Interpolate(jst.JSONEnum):
    """
    One of ['linear', 'linear-closed', 'step', 'step-before', 'step-after', 'basis', 'basis-open', 'basis-closed', 'cardinal', 'cardinal-open', 'cardinal-closed', 'bundle', 'monotone']
    """
    values = ['linear', 'linear-closed', 'step', 'step-before', 'step-after', 'basis', 'basis-open', 'basis-closed', 'cardinal', 'cardinal-open', 'cardinal-closed', 'bundle', 'monotone']
    def __init__(self, **kwargs):
        super(Interpolate, self).__init__(self.values, **kwargs)


class Mark(jst.JSONEnum):
    """
    One of ['area', 'bar', 'line', 'point', 'text', 'tick', 'rule', 'circle', 'square', 'errorBar']
    """
    values = ['area', 'bar', 'line', 'point', 'text', 'tick', 'rule', 'circle', 'square', 'errorBar']
    def __init__(self, **kwargs):
        super(Mark, self).__init__(self.values, **kwargs)


class NiceTime(jst.JSONEnum):
    """
    One of ['second', 'minute', 'hour', 'day', 'week', 'month', 'year']
    """
    values = ['second', 'minute', 'hour', 'day', 'week', 'month', 'year']
    def __init__(self, **kwargs):
        super(NiceTime, self).__init__(self.values, **kwargs)


class Orient(jst.JSONEnum):
    """
    One of ['horizontal', 'vertical']
    """
    values = ['horizontal', 'vertical']
    def __init__(self, **kwargs):
        super(Orient, self).__init__(self.values, **kwargs)


class ScaleType(jst.JSONEnum):
    """
    One of ['linear', 'log', 'pow', 'sqrt', 'quantile', 'quantize', 'ordinal', 'time', 'utc']
    """
    values = ['linear', 'log', 'pow', 'sqrt', 'quantile', 'quantize', 'ordinal', 'time', 'utc']
    def __init__(self, **kwargs):
        super(ScaleType, self).__init__(self.values, **kwargs)


class Shape(jst.JSONEnum):
    """
    One of ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']
    """
    values = ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']
    def __init__(self, **kwargs):
        super(Shape, self).__init__(self.values, **kwargs)


class SortOrder(jst.JSONEnum):
    """
    One of ['ascending', 'descending', 'none']
    """
    values = ['ascending', 'descending', 'none']
    def __init__(self, **kwargs):
        super(SortOrder, self).__init__(self.values, **kwargs)


class StackOffset(jst.JSONEnum):
    """
    One of ['zero', 'center', 'normalize', 'none']
    """
    values = ['zero', 'center', 'normalize', 'none']
    def __init__(self, **kwargs):
        super(StackOffset, self).__init__(self.values, **kwargs)


class TimeUnit(jst.JSONEnum):
    """
    One of ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'yearmonth', 'yearmonthdate', 'yearmonthdatehours', 'yearmonthdatehoursminutes', 'yearmonthdatehoursminutesseconds', 'monthdate', 'hoursminutes', 'hoursminutesseconds', 'minutesseconds', 'secondsmilliseconds', 'quarter', 'yearquarter', 'quartermonth', 'yearquartermonth']
    """
    values = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'yearmonth', 'yearmonthdate', 'yearmonthdatehours', 'yearmonthdatehoursminutes', 'yearmonthdatehoursminutesseconds', 'monthdate', 'hoursminutes', 'hoursminutesseconds', 'minutesseconds', 'secondsmilliseconds', 'quarter', 'yearquarter', 'quartermonth', 'yearquartermonth']
    def __init__(self, **kwargs):
        super(TimeUnit, self).__init__(self.values, **kwargs)


class Type(jst.JSONEnum):
    """
    One of ['quantitative', 'ordinal', 'temporal', 'nominal']
    """
    values = ['quantitative', 'ordinal', 'temporal', 'nominal']
    def __init__(self, **kwargs):
        super(Type, self).__init__(self.values, **kwargs)


class VerticalAlign(jst.JSONEnum):
    """
    One of ['top', 'middle', 'bottom']
    """
    values = ['top', 'middle', 'bottom']
    def __init__(self, **kwargs):
        super(VerticalAlign, self).__init__(self.values, **kwargs)


class Root(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('ExtendedUnitSpec')),jst.JSONInstance(_localname('FacetSpec')),jst.JSONInstance(_localname('LayerSpec')),)


class Axis(jst.JSONHasTraits):
    """Axis class

    

    Attributes
    ----------
    axisColor : string
        Color of axis line.
    axisWidth : number
        Width of the axis line
    characterWidth : number
        Character width for automatically determining title max
        length.
    format : string
        The formatting pattern for axis labels.
    grid : boolean
        A flag indicate if gridlines should be created in addition to
        ticks. If `grid` is unspecified, the default value is `true`
        for ROW and COL. For X and Y, the default value is `true` for
        quantitative and time fields and `false` otherwise.
    gridColor : string
        Color of gridlines.
    gridDash : Array(number)
        The offset (in pixels) into which to begin drawing with the
        grid dash array.
    gridOpacity : number
        The stroke opacity of grid (value between [0,1])
    gridWidth : number
        The grid width, in pixels.
    labelAlign : string
        Text alignment for the Label.
    labelAngle : number
        The rotation angle of the axis labels.
    labelBaseline : string
        Text baseline for the label.
    labelMaxLength : number
        Truncate labels that are too long.
    labels : boolean
        Enable or disable labels.
    layer : string
        A string indicating if the axis (and any gridlines) should be
        placed above or below the data marks.
    offset : number
        The offset, in pixels, by which to displace the axis from the
        edge of the enclosing group or data rectangle.
    orient : string
        The orientation of the axis. One of top, bottom, left or
        right. The orientation can be used to further specialize the
        axis type (e.g., a y axis oriented for the right edge of the
        chart).
    properties : Mapping
        Optional mark property definitions for custom axis styling.
    shortTimeLabels : boolean
        Whether month and day names should be abbreviated.
    subdivide : number
        If provided, sets the number of minor ticks between major
        ticks (the value 9 results in decimal subdivision). Only
        applicable for axes visualizing quantitative scales.
    tickColor : string
        The color of the axis's tick.
    tickLabelColor : string
        The color of the tick label, can be in hex color code or
        regular color name.
    tickLabelFont : string
        The font of the tick label.
    tickLabelFontSize : number
        The font size of label, in pixels.
    tickPadding : number
        The padding, in pixels, between ticks and text labels.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
    tickSizeEnd : number
        The size, in pixels, of end ticks.
    tickSizeMajor : number
        The size, in pixels, of major ticks.
    tickSizeMinor : number
        The size, in pixels, of minor ticks.
    tickWidth : number
        The width, in pixels, of ticks.
    ticks : number
        A desired number of ticks, for axes visualizing quantitative
        scales. The resulting number may be different so that values
        are "nice" (multiples of 2, 5, 10) and lie within the
        underlying scale's range.
    title : string
        A title for the axis. Shows field name and its function by
        default.
    titleColor : string
        Color of the title, can be in hex color code or regular color
        name.
    titleFont : string
        Font of the title.
    titleFontSize : number
        Size of the title.
    titleFontWeight : string
        Weight of the title.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
    titleOffset : number
        A title offset value for the axis.
    values : AnyOf([Array(number), Array(DateTime)])
        
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    axisColor = jst.JSONString(help='Color of axis line.')
    axisWidth = jst.JSONNumber(help='Width of the axis line')
    characterWidth = jst.JSONNumber(help='Character width for automatically determining title max length.')
    format = jst.JSONString(help='The formatting pattern for axis labels.')
    grid = jst.JSONBoolean(help='A flag indicate if gridlines should be created in addition to [...]')
    gridColor = jst.JSONString(help='Color of gridlines.')
    gridDash = jst.JSONArray(jst.JSONNumber(), help='The offset (in pixels) into which to begin drawing with the grid [...]')
    gridOpacity = jst.JSONNumber(help='The stroke opacity of grid (value between [0,1])')
    gridWidth = jst.JSONNumber(help='The grid width, in pixels.')
    labelAlign = jst.JSONString(help='Text alignment for the Label.')
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels.')
    labelBaseline = jst.JSONString(help='Text baseline for the label.')
    labelMaxLength = jst.JSONNumber(help='Truncate labels that are too long.', minimum=1)
    labels = jst.JSONBoolean(help='Enable or disable labels.')
    layer = jst.JSONString(help='A string indicating if the axis (and any gridlines) should be [...]')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the axis from the [...]')
    orient = AxisOrient()
    properties = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='Optional mark property definitions for custom axis styling.')
    shortTimeLabels = jst.JSONBoolean(help='Whether month and day names should be abbreviated.')
    subdivide = jst.JSONNumber(help='If provided, sets the number of minor ticks between major ticks [...]')
    tickColor = jst.JSONString(help="The color of the axis's tick.")
    tickLabelColor = jst.JSONString(help='The color of the tick label, can be in hex color code or regular [...]')
    tickLabelFont = jst.JSONString(help='The font of the tick label.')
    tickLabelFontSize = jst.JSONNumber(help='The font size of label, in pixels.')
    tickPadding = jst.JSONNumber(help='The padding, in pixels, between ticks and text labels.')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks.', minimum=0)
    tickSizeEnd = jst.JSONNumber(help='The size, in pixels, of end ticks.', minimum=0)
    tickSizeMajor = jst.JSONNumber(help='The size, in pixels, of major ticks.', minimum=0)
    tickSizeMinor = jst.JSONNumber(help='The size, in pixels, of minor ticks.', minimum=0)
    tickWidth = jst.JSONNumber(help='The width, in pixels, of ticks.')
    ticks = jst.JSONNumber(help='A desired number of ticks, for axes visualizing quantitative [...]', minimum=0)
    title = jst.JSONString(help='A title for the axis. Shows field name and its function by default.')
    titleColor = jst.JSONString(help='Color of the title, can be in hex color code or regular color name.')
    titleFont = jst.JSONString(help='Font of the title.')
    titleFontSize = jst.JSONNumber(help='Size of the title.')
    titleFontWeight = jst.JSONString(help='Weight of the title.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titleOffset = jst.JSONNumber(help='A title offset value for the axis.')
    values = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))])

    def __init__(self, axisColor=jst.undefined, axisWidth=jst.undefined, characterWidth=jst.undefined, format=jst.undefined, grid=jst.undefined, gridColor=jst.undefined, gridDash=jst.undefined, gridOpacity=jst.undefined, gridWidth=jst.undefined, labelAlign=jst.undefined, labelAngle=jst.undefined, labelBaseline=jst.undefined, labelMaxLength=jst.undefined, labels=jst.undefined, layer=jst.undefined, offset=jst.undefined, orient=jst.undefined, properties=jst.undefined, shortTimeLabels=jst.undefined, subdivide=jst.undefined, tickColor=jst.undefined, tickLabelColor=jst.undefined, tickLabelFont=jst.undefined, tickLabelFontSize=jst.undefined, tickPadding=jst.undefined, tickSize=jst.undefined, tickSizeEnd=jst.undefined, tickSizeMajor=jst.undefined, tickSizeMinor=jst.undefined, tickWidth=jst.undefined, ticks=jst.undefined, title=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleMaxLength=jst.undefined, titleOffset=jst.undefined, values=jst.undefined, **kwargs):
        kwds = dict(axisColor=axisColor, axisWidth=axisWidth, characterWidth=characterWidth, format=format, grid=grid, gridColor=gridColor, gridDash=gridDash, gridOpacity=gridOpacity, gridWidth=gridWidth, labelAlign=labelAlign, labelAngle=labelAngle, labelBaseline=labelBaseline, labelMaxLength=labelMaxLength, labels=labels, layer=layer, offset=offset, orient=orient, properties=properties, shortTimeLabels=shortTimeLabels, subdivide=subdivide, tickColor=tickColor, tickLabelColor=tickLabelColor, tickLabelFont=tickLabelFont, tickLabelFontSize=tickLabelFontSize, tickPadding=tickPadding, tickSize=tickSize, tickSizeEnd=tickSizeEnd, tickSizeMajor=tickSizeMajor, tickSizeMinor=tickSizeMinor, tickWidth=tickWidth, ticks=ticks, title=title, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleMaxLength=titleMaxLength, titleOffset=titleOffset, values=values)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Axis, self).__init__(**kwargs)


class AxisConfig(jst.JSONHasTraits):
    """AxisConfig class

    

    Attributes
    ----------
    axisColor : string
        Color of axis line.
    axisWidth : number
        Width of the axis line
    characterWidth : number
        Character width for automatically determining title max
        length.
    grid : boolean
        A flag indicate if gridlines should be created in addition to
        ticks. If `grid` is unspecified, the default value is `true`
        for ROW and COL. For X and Y, the default value is `true` for
        quantitative and time fields and `false` otherwise.
    gridColor : string
        Color of gridlines.
    gridDash : Array(number)
        The offset (in pixels) into which to begin drawing with the
        grid dash array.
    gridOpacity : number
        The stroke opacity of grid (value between [0,1])
    gridWidth : number
        The grid width, in pixels.
    labelAlign : string
        Text alignment for the Label.
    labelAngle : number
        The rotation angle of the axis labels.
    labelBaseline : string
        Text baseline for the label.
    labelMaxLength : number
        Truncate labels that are too long.
    labels : boolean
        Enable or disable labels.
    layer : string
        A string indicating if the axis (and any gridlines) should be
        placed above or below the data marks.
    offset : number
        The offset, in pixels, by which to displace the axis from the
        edge of the enclosing group or data rectangle.
    properties : Mapping
        Optional mark property definitions for custom axis styling.
    shortTimeLabels : boolean
        Whether month and day names should be abbreviated.
    subdivide : number
        If provided, sets the number of minor ticks between major
        ticks (the value 9 results in decimal subdivision). Only
        applicable for axes visualizing quantitative scales.
    tickColor : string
        The color of the axis's tick.
    tickLabelColor : string
        The color of the tick label, can be in hex color code or
        regular color name.
    tickLabelFont : string
        The font of the tick label.
    tickLabelFontSize : number
        The font size of label, in pixels.
    tickPadding : number
        The padding, in pixels, between ticks and text labels.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
    tickSizeEnd : number
        The size, in pixels, of end ticks.
    tickSizeMajor : number
        The size, in pixels, of major ticks.
    tickSizeMinor : number
        The size, in pixels, of minor ticks.
    tickWidth : number
        The width, in pixels, of ticks.
    ticks : number
        A desired number of ticks, for axes visualizing quantitative
        scales. The resulting number may be different so that values
        are "nice" (multiples of 2, 5, 10) and lie within the
        underlying scale's range.
    titleColor : string
        Color of the title, can be in hex color code or regular color
        name.
    titleFont : string
        Font of the title.
    titleFontSize : number
        Size of the title.
    titleFontWeight : string
        Weight of the title.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
    titleOffset : number
        A title offset value for the axis.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    axisColor = jst.JSONString(help='Color of axis line.')
    axisWidth = jst.JSONNumber(help='Width of the axis line')
    characterWidth = jst.JSONNumber(help='Character width for automatically determining title max length.')
    grid = jst.JSONBoolean(help='A flag indicate if gridlines should be created in addition to [...]')
    gridColor = jst.JSONString(help='Color of gridlines.')
    gridDash = jst.JSONArray(jst.JSONNumber(), help='The offset (in pixels) into which to begin drawing with the grid [...]')
    gridOpacity = jst.JSONNumber(help='The stroke opacity of grid (value between [0,1])')
    gridWidth = jst.JSONNumber(help='The grid width, in pixels.')
    labelAlign = jst.JSONString(help='Text alignment for the Label.')
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels.')
    labelBaseline = jst.JSONString(help='Text baseline for the label.')
    labelMaxLength = jst.JSONNumber(help='Truncate labels that are too long.', minimum=1)
    labels = jst.JSONBoolean(help='Enable or disable labels.')
    layer = jst.JSONString(help='A string indicating if the axis (and any gridlines) should be [...]')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the axis from the [...]')
    properties = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='Optional mark property definitions for custom axis styling.')
    shortTimeLabels = jst.JSONBoolean(help='Whether month and day names should be abbreviated.')
    subdivide = jst.JSONNumber(help='If provided, sets the number of minor ticks between major ticks [...]')
    tickColor = jst.JSONString(help="The color of the axis's tick.")
    tickLabelColor = jst.JSONString(help='The color of the tick label, can be in hex color code or regular [...]')
    tickLabelFont = jst.JSONString(help='The font of the tick label.')
    tickLabelFontSize = jst.JSONNumber(help='The font size of label, in pixels.')
    tickPadding = jst.JSONNumber(help='The padding, in pixels, between ticks and text labels.')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks.', minimum=0)
    tickSizeEnd = jst.JSONNumber(help='The size, in pixels, of end ticks.', minimum=0)
    tickSizeMajor = jst.JSONNumber(help='The size, in pixels, of major ticks.', minimum=0)
    tickSizeMinor = jst.JSONNumber(help='The size, in pixels, of minor ticks.', minimum=0)
    tickWidth = jst.JSONNumber(help='The width, in pixels, of ticks.')
    ticks = jst.JSONNumber(help='A desired number of ticks, for axes visualizing quantitative [...]', minimum=0)
    titleColor = jst.JSONString(help='Color of the title, can be in hex color code or regular color name.')
    titleFont = jst.JSONString(help='Font of the title.')
    titleFontSize = jst.JSONNumber(help='Size of the title.')
    titleFontWeight = jst.JSONString(help='Weight of the title.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titleOffset = jst.JSONNumber(help='A title offset value for the axis.')

    def __init__(self, axisColor=jst.undefined, axisWidth=jst.undefined, characterWidth=jst.undefined, grid=jst.undefined, gridColor=jst.undefined, gridDash=jst.undefined, gridOpacity=jst.undefined, gridWidth=jst.undefined, labelAlign=jst.undefined, labelAngle=jst.undefined, labelBaseline=jst.undefined, labelMaxLength=jst.undefined, labels=jst.undefined, layer=jst.undefined, offset=jst.undefined, properties=jst.undefined, shortTimeLabels=jst.undefined, subdivide=jst.undefined, tickColor=jst.undefined, tickLabelColor=jst.undefined, tickLabelFont=jst.undefined, tickLabelFontSize=jst.undefined, tickPadding=jst.undefined, tickSize=jst.undefined, tickSizeEnd=jst.undefined, tickSizeMajor=jst.undefined, tickSizeMinor=jst.undefined, tickWidth=jst.undefined, ticks=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleMaxLength=jst.undefined, titleOffset=jst.undefined, **kwargs):
        kwds = dict(axisColor=axisColor, axisWidth=axisWidth, characterWidth=characterWidth, grid=grid, gridColor=gridColor, gridDash=gridDash, gridOpacity=gridOpacity, gridWidth=gridWidth, labelAlign=labelAlign, labelAngle=labelAngle, labelBaseline=labelBaseline, labelMaxLength=labelMaxLength, labels=labels, layer=layer, offset=offset, properties=properties, shortTimeLabels=shortTimeLabels, subdivide=subdivide, tickColor=tickColor, tickLabelColor=tickLabelColor, tickLabelFont=tickLabelFont, tickLabelFontSize=tickLabelFontSize, tickPadding=tickPadding, tickSize=tickSize, tickSizeEnd=tickSizeEnd, tickSizeMajor=tickSizeMajor, tickSizeMinor=tickSizeMinor, tickWidth=tickWidth, ticks=ticks, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleMaxLength=titleMaxLength, titleOffset=titleOffset)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(AxisConfig, self).__init__(**kwargs)


class Bin(jst.JSONHasTraits):
    """Bin class

    Binning properties or boolean flag for determining whether to bin
    data or not.

    Attributes
    ----------
    base : number
        The number base to use for automatic bin determination
        (default is base 10).
    div : Array(number)
        Scale factors indicating allowable subdivisions. The default
        value is [5, 2], which indicates that for base 10 numbers (the
        default base), the method may consider dividing bin sizes by 5
        and/or 2. For example, for an initial step size of 10, the
        method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1
        (= 10/(5*2)) might also satisfy the given constraints.
    max : number
        The maximum bin value to consider. If unspecified, the maximum
        value of the specified field is used.
    maxbins : number
        Maximum number of bins.
    min : number
        The minimum bin value to consider. If unspecified, the minimum
        value of the specified field is used.
    minstep : number
        A minimum allowable step size (particularly useful for integer
        values).
    step : number
        An exact step size to use between bins. If provided, options
        such as maxbins will be ignored.
    steps : Array(number)
        An array of allowable step sizes to choose from.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    base = jst.JSONNumber(help='The number base to use for automatic bin determination (default [...]')
    div = jst.JSONArray(jst.JSONNumber(), help='Scale factors indicating allowable subdivisions. The default [...]')
    max = jst.JSONNumber(help='The maximum bin value to consider. If unspecified, the maximum [...]')
    maxbins = jst.JSONNumber(help='Maximum number of bins.', minimum=2)
    min = jst.JSONNumber(help='The minimum bin value to consider. If unspecified, the minimum [...]')
    minstep = jst.JSONNumber(help='A minimum allowable step size (particularly useful for integer [...]')
    step = jst.JSONNumber(help='An exact step size to use between bins. If provided, options [...]')
    steps = jst.JSONArray(jst.JSONNumber(), help='An array of allowable step sizes to choose from.')

    def __init__(self, base=jst.undefined, div=jst.undefined, max=jst.undefined, maxbins=jst.undefined, min=jst.undefined, minstep=jst.undefined, step=jst.undefined, steps=jst.undefined, **kwargs):
        kwds = dict(base=base, div=div, max=max, maxbins=maxbins, min=min, minstep=minstep, step=step, steps=steps)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Bin, self).__init__(**kwargs)


class CellConfig(jst.JSONHasTraits):
    """CellConfig class

    

    Attributes
    ----------
    clip : boolean
        
    fill : string
        The fill color.
    fillOpacity : number
        The fill opacity (value between [0,1]).
    height : number
        
    stroke : string
        The stroke color.
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
    strokeWidth : number
        The stroke width, in pixels.
    width : number
        
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    clip = jst.JSONBoolean()
    fill = jst.JSONString(help='The fill color.')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]).')
    height = jst.JSONNumber()
    stroke = jst.JSONString(help='The stroke color.')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]).')
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.')
    width = jst.JSONNumber()

    def __init__(self, clip=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, height=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(clip=clip, fill=fill, fillOpacity=fillOpacity, height=height, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(CellConfig, self).__init__(**kwargs)


class ChannelDefWithLegend(jst.JSONHasTraits):
    """ChannelDefWithLegend class

    

    Attributes
    ----------
    aggregate : string
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : string
        Name of the field from which to pull a data value.
    legend : Legend
        
    scale : Scale
        
    sort : AnyOf([SortField, string])
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
    title : string
        Title for axis or legend.
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case insensitive.
    value : ['number', 'string', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    aggregate = AggregateOp()
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONString(help='Name of the field from which to pull a data value.')
    legend = jst.JSONInstance(_localname('Legend'))
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), SortOrder()])
    timeUnit = TimeUnit()
    title = jst.JSONString(help='Title for axis or legend.')
    type = Type()
    value = jst.JSONUnion([jst.JSONNumber(), jst.JSONString(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, legend=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, title=jst.undefined, type=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, legend=legend, scale=scale, sort=sort, timeUnit=timeUnit, title=title, type=type, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ChannelDefWithLegend, self).__init__(**kwargs)


class Config(jst.JSONHasTraits):
    """Config class

    

    Attributes
    ----------
    axis : AxisConfig
        Axis Config
    background : string
        CSS color property to use as background of visualization.
        Default is `"transparent"`.
    cell : CellConfig
        Cell Config
    countTitle : string
        Default axis and legend title for count fields.
    facet : FacetConfig
        Facet Config
    legend : LegendConfig
        Legend Config
    mark : MarkConfig
        Mark Config
    numberFormat : string
        D3 Number format for axis labels and text tables. For example
        "s" for SI units.
    overlay : OverlayConfig
        Mark Overlay Config
    scale : ScaleConfig
        Scale Config
    timeFormat : string
        Default datetime format for axis and legend labels. The format
        can be set directly on each axis and legend.
    viewport : number
        The width and height of the on-screen viewport, in pixels. If
        necessary, clipping and scrolling will be applied.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    axis = jst.JSONInstance(_localname('AxisConfig'), help='Axis Config')
    background = jst.JSONString(help='CSS color property to use as background of visualization. [...]')
    cell = jst.JSONInstance(_localname('CellConfig'), help='Cell Config')
    countTitle = jst.JSONString(help='Default axis and legend title for count fields.')
    facet = jst.JSONInstance(_localname('FacetConfig'), help='Facet Config')
    legend = jst.JSONInstance(_localname('LegendConfig'), help='Legend Config')
    mark = jst.JSONInstance(_localname('MarkConfig'), help='Mark Config')
    numberFormat = jst.JSONString(help='D3 Number format for axis labels and text tables. For example [...]')
    overlay = jst.JSONInstance(_localname('OverlayConfig'), help='Mark Overlay Config')
    scale = jst.JSONInstance(_localname('ScaleConfig'), help='Scale Config')
    timeFormat = jst.JSONString(help='Default datetime format for axis and legend labels. The format [...]')
    viewport = jst.JSONNumber(help='The width and height of the on-screen viewport, in pixels. If [...]')

    def __init__(self, axis=jst.undefined, background=jst.undefined, cell=jst.undefined, countTitle=jst.undefined, facet=jst.undefined, legend=jst.undefined, mark=jst.undefined, numberFormat=jst.undefined, overlay=jst.undefined, scale=jst.undefined, timeFormat=jst.undefined, viewport=jst.undefined, **kwargs):
        kwds = dict(axis=axis, background=background, cell=cell, countTitle=countTitle, facet=facet, legend=legend, mark=mark, numberFormat=numberFormat, overlay=overlay, scale=scale, timeFormat=timeFormat, viewport=viewport)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Config, self).__init__(**kwargs)


class Data(jst.JSONHasTraits):
    """Data class

    

    Attributes
    ----------
    format : DataFormat
        An object that specifies the format for the data file or
        values.
    url : string
        A URL from which to load the data set. Use the format.type
        property
        to ensure the loaded data is correctly parsed.
    values : Array(any_object)
        Pass array of objects instead of a url to a file.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    format = jst.JSONInstance(_localname('DataFormat'), help='An object that specifies the format for the data file or values.')
    url = jst.JSONString(help='A URL from which to load the data set. Use the format.type [...]')
    values = jst.JSONArray(jst.JSONAny(), help='Pass array of objects instead of a url to a file.')

    def __init__(self, format=jst.undefined, url=jst.undefined, values=jst.undefined, **kwargs):
        kwds = dict(format=format, url=url, values=values)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Data, self).__init__(**kwargs)


class DataFormat(jst.JSONHasTraits):
    """DataFormat class

    

    Attributes
    ----------
    feature : string
        The name of the TopoJSON object set to convert to a GeoJSON
        feature collection.
        For example, in a map of the world, there may be an object set
        named `"countries"`.
        Using the feature property, we can extract this set and
        generate a GeoJSON feature object for each country.
    mesh : string
        The name of the TopoJSON object set to convert to a mesh.
        Similar to the `feature` option, `mesh` extracts a named
        TopoJSON object set.
        Unlike the `feature` option, the corresponding geo data is
        returned as a single, unified mesh instance, not as individual
        GeoJSON features.
        Extracting a mesh is useful for more efficiently drawing
        borders or other geographic elements that you do not need to
        associate with specific regions such as individual countries,
        states or counties.
    parse : Mapping
        A collection of parsing instructions can be used to define the
        data types of string-valued attributes in the JSON file. Each
        instruction is a name-value pair, where the name is the name
        of the attribute, and the value is the desired data type (one
        of `"number"`, `"boolean"` or `"date"`). For example,
        `"parse": {"modified_on":"date"}` ensures that the
        `modified_on` value in each row of the input data is parsed as
        a Date value. (See Datalib's [`dl.read.types` method](https://
        github.com/vega/datalib/wiki/Import#dl_read_types) for more
        information.)
    property : string
        JSON only) The JSON property containing the desired data.
        This parameter can be used when the loaded JSON file may have
        surrounding structure or meta-data.
        For example `"property": "values.features"` is equivalent to
        retrieving `json.values.features`
        from the loaded JSON object.
    type : string
        Type of input data: `"json"`, `"csv"`, `"tsv"`.
        The default format type is determined by the extension of the
        file url.
        If no extension is detected, `"json"` will be used by default.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    feature = jst.JSONString(help='The name of the TopoJSON object set to convert to a GeoJSON [...]')
    mesh = jst.JSONString(help='The name of the TopoJSON object set to convert to a mesh. [...]')
    parse = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A collection of parsing instructions can be used to define the [...]')
    property = jst.JSONString(help='JSON only) The JSON property containing the desired data. This [...]')
    type = DataFormatType()

    def __init__(self, feature=jst.undefined, mesh=jst.undefined, parse=jst.undefined, property=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(feature=feature, mesh=mesh, parse=parse, property=property, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(DataFormat, self).__init__(**kwargs)


class DateTime(jst.JSONHasTraits):
    """DateTime class

    Object for defining datetime in Vega-Lite Filter.
    If both month and quarter are provided, month has higher
    precedence.
    `day` cannot be combined with other date.
    We accept string for month and day names.

    Attributes
    ----------
    date : number
        Integer value representing the date from 1-31.
    day : ['number', 'string']
        Value representing the day of week.  This can be one of: (1)
        integer value -- `1` represents Monday; (2) case-insensitive
        day name (e.g., `"Monday"`);  (3) case-insensitive,
        3-character short day name (e.g., `"Mon"`).   <br/>
        **Warning:** A DateTime definition object with `day`** should
        not be combined with `year`, `quarter`, `month`, or `date`.
    hours : number
        Integer value representing the hour of day from 0-23.
    milliseconds : number
        Integer value representing millisecond segment of a time.
    minutes : number
        Integer value representing minute segment of a time from 0-59.
    month : ['number', 'string']
        One of: (1) integer value representing the month from
        `1`-`12`. `1` represents January;  (2) case-insensitive month
        name (e.g., `"January"`);  (3) case-insensitive, 3-character
        short month name (e.g., `"Jan"`).
    quarter : number
        Integer value representing the quarter of the year (from 1-4).
    seconds : number
        Integer value representing second segment of a time from 0-59.
    year : number
        Integer value representing the year.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    date = jst.JSONNumber(help='Integer value representing the date from 1-31.', maximum=31, minimum=1)
    day = jst.JSONUnion([jst.JSONNumber(), jst.JSONString()], help='Value representing the day of week. This can be one of: (1) [...]')
    hours = jst.JSONNumber(help='Integer value representing the hour of day from 0-23.', maximum=23, minimum=0)
    milliseconds = jst.JSONNumber(help='Integer value representing millisecond segment of a time.', maximum=999, minimum=0)
    minutes = jst.JSONNumber(help='Integer value representing minute segment of a time from 0-59.', maximum=59, minimum=0)
    month = jst.JSONUnion([jst.JSONNumber(), jst.JSONString()], help='One of: (1) integer value representing the month from `1`-`12`. [...]')
    quarter = jst.JSONNumber(help='Integer value representing the quarter of the year (from 1-4).', maximum=4, minimum=1)
    seconds = jst.JSONNumber(help='Integer value representing second segment of a time from 0-59.', maximum=59, minimum=0)
    year = jst.JSONNumber(help='Integer value representing the year.')

    def __init__(self, date=jst.undefined, day=jst.undefined, hours=jst.undefined, milliseconds=jst.undefined, minutes=jst.undefined, month=jst.undefined, quarter=jst.undefined, seconds=jst.undefined, year=jst.undefined, **kwargs):
        kwds = dict(date=date, day=day, hours=hours, milliseconds=milliseconds, minutes=minutes, month=month, quarter=quarter, seconds=seconds, year=year)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(DateTime, self).__init__(**kwargs)


class Encoding(jst.JSONHasTraits):
    """Encoding class

    

    Attributes
    ----------
    color : ChannelDefWithLegend
        Color of the marks – either fill or stroke color based on mark
        type.
        (By default, fill color for `area`, `bar`, `tick`, `text`,
        `circle`, and `square` /
        stroke color for `line` and `point`.)
    column : PositionChannelDef
        Horizontal facets for trellis plots.
    detail : AnyOf([FieldDef, Array(FieldDef)])
        Additional levels of detail for grouping data in aggregate
        views and
        in line and area marks without mapping data to a specific
        visual channel.
    label : FieldDef
        
    opacity : ChannelDefWithLegend
        Opacity of the marks – either can be a value or in a range.
    order : AnyOf([OrderChannelDef, Array(OrderChannelDef)])
        Layer order for non-stacked marks, or stack order for stacked
        marks.
    path : AnyOf([OrderChannelDef, Array(OrderChannelDef)])
        Order of data points in line marks.
    row : PositionChannelDef
        Vertical facets for trellis plots.
    shape : ChannelDefWithLegend
        The symbol's shape (only for `point` marks). The supported
        values are
        `"circle"` (default), `"square"`, `"cross"`, `"diamond"`,
        `"triangle-up"`,
        or `"triangle-down"`, or else a custom SVG path string.
    size : ChannelDefWithLegend
        Size of the mark.
        - For `point`, `square` and `circle`
        – the symbol size, or pixel area of the mark.
        - For `bar` and `tick` – the bar and tick's size.
        - For `text` – the text's font size.
        - Size is currently unsupported for `line` and `area`.
    text : FieldDef
        Text of the `text` mark.
    x : PositionChannelDef
        X coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    x2 : FieldDef
        X2 coordinates for ranged `bar`, `rule`, `area`
    y : PositionChannelDef
        Y coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    y2 : FieldDef
        Y2 coordinates for ranged `bar`, `rule`, `area`
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Color of the marks – either fill or stroke color based on mark [...]')
    column = jst.JSONInstance(_localname('PositionChannelDef'), help='Horizontal facets for trellis plots.')
    detail = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONArray(jst.JSONInstance(_localname('FieldDef')))], help='Additional levels of detail for grouping data in aggregate views [...]')
    label = jst.JSONInstance(_localname('FieldDef'))
    opacity = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Opacity of the marks – either can be a value or in a range.')
    order = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderChannelDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderChannelDef')))], help='Layer order for non-stacked marks, or stack order for stacked marks.')
    path = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderChannelDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderChannelDef')))], help='Order of data points in line marks.')
    row = jst.JSONInstance(_localname('PositionChannelDef'), help='Vertical facets for trellis plots.')
    shape = jst.JSONInstance(_localname('ChannelDefWithLegend'), help="The symbol's shape (only for `point` marks). The supported [...]")
    size = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Size of the mark. - For `point`, `square` and `circle` – the [...]')
    text = jst.JSONInstance(_localname('FieldDef'), help='Text of the `text` mark.')
    x = jst.JSONInstance(_localname('PositionChannelDef'), help='X coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    x2 = jst.JSONInstance(_localname('FieldDef'), help='X2 coordinates for ranged `bar`, `rule`, `area`')
    y = jst.JSONInstance(_localname('PositionChannelDef'), help='Y coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    y2 = jst.JSONInstance(_localname('FieldDef'), help='Y2 coordinates for ranged `bar`, `rule`, `area`')

    def __init__(self, color=jst.undefined, column=jst.undefined, detail=jst.undefined, label=jst.undefined, opacity=jst.undefined, order=jst.undefined, path=jst.undefined, row=jst.undefined, shape=jst.undefined, size=jst.undefined, text=jst.undefined, x=jst.undefined, x2=jst.undefined, y=jst.undefined, y2=jst.undefined, **kwargs):
        kwds = dict(color=color, column=column, detail=detail, label=label, opacity=opacity, order=order, path=path, row=row, shape=shape, size=size, text=text, x=x, x2=x2, y=y, y2=y2)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Encoding, self).__init__(**kwargs)


class EqualFilter(jst.JSONHasTraits):
    """EqualFilter class

    

    Attributes
    ----------
    equal : AnyOf([string, number, boolean, DateTime])
        Value that the field should be equal to.
    field : string
        Field to be filtered.
    timeUnit : string
        Time unit for the field to be filtered.
    """
    _additional_traits = True
    _required_traits = ['field', 'equal']
    _trait_name_map = {}
    equal = jst.JSONAnyOf([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean(), jst.JSONInstance(_localname('DateTime'))], help='Value that the field should be equal to.')
    field = jst.JSONString(help='Field to be filtered.')
    timeUnit = TimeUnit()

    def __init__(self, equal=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(equal=equal, field=field, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(EqualFilter, self).__init__(**kwargs)


class ExtendedUnitSpec(jst.JSONHasTraits):
    """ExtendedUnitSpec class

    Schema for a unit Vega-Lite specification, with the syntactic
    sugar extensions:
    - `row` and `column` are included in the encoding.
    - (Future) label, box plot
    Note: the spec could contain facet.

    Attributes
    ----------
    config : Config
        Configuration object
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
        This property has no effect on the output visualization.
    encoding : Encoding
        A key-value mapping between encoding channels and definition
        of fields.
    height : number
        
    mark : string
        The mark type.
        One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`.
    name : string
        Name of the visualization for later reference.
    transform : Transform
        An object describing filter and new field calculation.
    width : number
        
    """
    _additional_traits = True
    _required_traits = ['mark']
    _trait_name_map = {}
    config = jst.JSONInstance(_localname('Config'), help='Configuration object')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose. [...]')
    encoding = jst.JSONInstance(_localname('Encoding'), help='A key-value mapping between encoding channels and definition of [...]')
    height = jst.JSONNumber()
    mark = Mark()
    name = jst.JSONString(help='Name of the visualization for later reference.')
    transform = jst.JSONInstance(_localname('Transform'), help='An object describing filter and new field calculation.')
    width = jst.JSONNumber()

    def __init__(self, config=jst.undefined, data=jst.undefined, description=jst.undefined, encoding=jst.undefined, height=jst.undefined, mark=jst.undefined, name=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(config=config, data=data, description=description, encoding=encoding, height=height, mark=mark, name=name, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ExtendedUnitSpec, self).__init__(**kwargs)


class Facet(jst.JSONHasTraits):
    """Facet class

    

    Attributes
    ----------
    column : PositionChannelDef
        
    row : PositionChannelDef
        
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    column = jst.JSONInstance(_localname('PositionChannelDef'))
    row = jst.JSONInstance(_localname('PositionChannelDef'))

    def __init__(self, column=jst.undefined, row=jst.undefined, **kwargs):
        kwds = dict(column=column, row=row)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Facet, self).__init__(**kwargs)


class FacetConfig(jst.JSONHasTraits):
    """FacetConfig class

    

    Attributes
    ----------
    axis : AxisConfig
        Facet Axis Config
    cell : CellConfig
        Facet Cell Config
    grid : FacetGridConfig
        Facet Grid Config
    scale : FacetScaleConfig
        Facet Scale Config
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    axis = jst.JSONInstance(_localname('AxisConfig'), help='Facet Axis Config')
    cell = jst.JSONInstance(_localname('CellConfig'), help='Facet Cell Config')
    grid = jst.JSONInstance(_localname('FacetGridConfig'), help='Facet Grid Config')
    scale = jst.JSONInstance(_localname('FacetScaleConfig'), help='Facet Scale Config')

    def __init__(self, axis=jst.undefined, cell=jst.undefined, grid=jst.undefined, scale=jst.undefined, **kwargs):
        kwds = dict(axis=axis, cell=cell, grid=grid, scale=scale)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetConfig, self).__init__(**kwargs)


class FacetGridConfig(jst.JSONHasTraits):
    """FacetGridConfig class

    

    Attributes
    ----------
    color : string
        
    offset : number
        
    opacity : number
        
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONString()
    offset = jst.JSONNumber()
    opacity = jst.JSONNumber()

    def __init__(self, color=jst.undefined, offset=jst.undefined, opacity=jst.undefined, **kwargs):
        kwds = dict(color=color, offset=offset, opacity=opacity)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetGridConfig, self).__init__(**kwargs)


class FacetScaleConfig(jst.JSONHasTraits):
    """FacetScaleConfig class

    

    Attributes
    ----------
    padding : number
        
    round : boolean
        
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    padding = jst.JSONNumber()
    round = jst.JSONBoolean()

    def __init__(self, padding=jst.undefined, round=jst.undefined, **kwargs):
        kwds = dict(padding=padding, round=round)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetScaleConfig, self).__init__(**kwargs)


class FacetSpec(jst.JSONHasTraits):
    """FacetSpec class

    

    Attributes
    ----------
    config : Config
        Configuration object
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
        This property has no effect on the output visualization.
    facet : Facet
        
    name : string
        Name of the visualization for later reference.
    spec : AnyOf([LayerSpec, UnitSpec])
        
    transform : Transform
        An object describing filter and new field calculation.
    """
    _additional_traits = True
    _required_traits = ['facet', 'spec']
    _trait_name_map = {}
    config = jst.JSONInstance(_localname('Config'), help='Configuration object')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose. [...]')
    facet = jst.JSONInstance(_localname('Facet'))
    name = jst.JSONString(help='Name of the visualization for later reference.')
    spec = jst.JSONAnyOf([jst.JSONInstance(_localname('LayerSpec')), jst.JSONInstance(_localname('UnitSpec'))])
    transform = jst.JSONInstance(_localname('Transform'), help='An object describing filter and new field calculation.')

    def __init__(self, config=jst.undefined, data=jst.undefined, description=jst.undefined, facet=jst.undefined, name=jst.undefined, spec=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(config=config, data=data, description=description, facet=facet, name=name, spec=spec, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetSpec, self).__init__(**kwargs)


class FieldDef(jst.JSONHasTraits):
    """FieldDef class

    

    Attributes
    ----------
    aggregate : string
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : string
        Name of the field from which to pull a data value.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
    title : string
        Title for axis or legend.
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case insensitive.
    value : ['number', 'string', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    aggregate = AggregateOp()
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONString(help='Name of the field from which to pull a data value.')
    timeUnit = TimeUnit()
    title = jst.JSONString(help='Title for axis or legend.')
    type = Type()
    value = jst.JSONUnion([jst.JSONNumber(), jst.JSONString(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, title=jst.undefined, type=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, timeUnit=timeUnit, title=title, type=type, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FieldDef, self).__init__(**kwargs)


class Formula(jst.JSONHasTraits):
    """Formula class

    Formula object for calculate.

    Attributes
    ----------
    expr : string
        A string containing an expression for the formula. Use the
        variable `datum` to to refer to the current data object.
    field : string
        The field in which to store the computed formula value.
    """
    _additional_traits = True
    _required_traits = ['field', 'expr']
    _trait_name_map = {}
    expr = jst.JSONString(help='A string containing an expression for the formula. Use the [...]')
    field = jst.JSONString(help='The field in which to store the computed formula value.')

    def __init__(self, expr=jst.undefined, field=jst.undefined, **kwargs):
        kwds = dict(expr=expr, field=field)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Formula, self).__init__(**kwargs)


class LayerSpec(jst.JSONHasTraits):
    """LayerSpec class

    

    Attributes
    ----------
    config : Config
        Configuration object
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
        This property has no effect on the output visualization.
    height : number
        
    layers : Array(UnitSpec)
        Unit specs that will be layered.
    name : string
        Name of the visualization for later reference.
    transform : Transform
        An object describing filter and new field calculation.
    width : number
        
    """
    _additional_traits = True
    _required_traits = ['layers']
    _trait_name_map = {}
    config = jst.JSONInstance(_localname('Config'), help='Configuration object')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose. [...]')
    height = jst.JSONNumber()
    layers = jst.JSONArray(jst.JSONInstance(_localname('UnitSpec')), help='Unit specs that will be layered.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    transform = jst.JSONInstance(_localname('Transform'), help='An object describing filter and new field calculation.')
    width = jst.JSONNumber()

    def __init__(self, config=jst.undefined, data=jst.undefined, description=jst.undefined, height=jst.undefined, layers=jst.undefined, name=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(config=config, data=data, description=description, height=height, layers=layers, name=name, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LayerSpec, self).__init__(**kwargs)


class Legend(jst.JSONHasTraits):
    """Legend class

    

    Attributes
    ----------
    format : string
        An optional formatting pattern for legend labels. Vega uses
        D3\'s format pattern.
    gradientHeight : number
        The height of the gradient, in pixels.
    gradientStrokeColor : string
        The color of the gradient stroke, can be in hex color code or
        regular color name.
    gradientStrokeWidth : number
        The width of the gradient stroke, in pixels.
    gradientWidth : number
        The width of the gradient, in pixels.
    labelAlign : string
        The alignment of the legend label, can be left, middle or
        right.
    labelBaseline : string
        The position of the baseline of legend label, can be top,
        middle or bottom.
    labelColor : string
        The color of the legend label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the legend label.
    labelFontSize : number
        The font size of legend label.
    labelOffset : number
        The offset of the legend label.
    margin : number
        The margin around the legend, in pixels
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
    orient : string
        The orientation of the legend. One of "left" or "right". This
        determines how the legend is positioned within the scene. The
        default is "right".
    padding : number
        The padding, in pixels, between the legend and axis.
    properties : Mapping
        Optional mark property definitions for custom legend styling.
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
    symbolColor : string
        The color of the legend symbol,
    symbolShape : string
        The shape of the legend symbol, can be the 'circle', 'square',
        'cross', 'diamond',
        'triangle-up', 'triangle-down', or else a custom SVG path
        string.
    symbolSize : number
        The size of the legend symbol, in pixels.
    symbolStrokeWidth : number
        The width of the symbol's stroke.
    title : string
        A title for the legend. (Shows field name and its function by
        default.)
    titleColor : string
        Optional mark property definitions for custom legend styling.
        The color of the legend title, can be in hex color code or
        regular color name.
    titleFont : string
        The font of the legend title.
    titleFontSize : number
        The font size of the legend title.
    titleFontWeight : string
        The font weight of the legend title.
    values : AnyOf([Array(number), Array(string), Array(DateTime)])
        Explicitly set the visible legend values.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    format = jst.JSONString(help='An optional formatting pattern for legend labels. Vega uses [...]')
    gradientHeight = jst.JSONNumber(help='The height of the gradient, in pixels.')
    gradientStrokeColor = jst.JSONString(help='The color of the gradient stroke, can be in hex color code or [...]')
    gradientStrokeWidth = jst.JSONNumber(help='The width of the gradient stroke, in pixels.')
    gradientWidth = jst.JSONNumber(help='The width of the gradient, in pixels.')
    labelAlign = jst.JSONString(help='The alignment of the legend label, can be left, middle or right.')
    labelBaseline = jst.JSONString(help='The position of the baseline of legend label, can be top, middle [...]')
    labelColor = jst.JSONString(help='The color of the legend label, can be in hex color code or [...]')
    labelFont = jst.JSONString(help='The font of the legend label.')
    labelFontSize = jst.JSONNumber(help='The font size of legend label.')
    labelOffset = jst.JSONNumber(help='The offset of the legend label.')
    margin = jst.JSONNumber(help='The margin around the legend, in pixels')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = jst.JSONString(help='The orientation of the legend. One of "left" or "right". This [...]')
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    properties = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='Optional mark property definitions for custom legend styling.')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated.')
    symbolColor = jst.JSONString(help='The color of the legend symbol,')
    symbolShape = jst.JSONString(help="The shape of the legend symbol, can be the 'circle', 'square', [...]")
    symbolSize = jst.JSONNumber(help='The size of the legend symbol, in pixels.')
    symbolStrokeWidth = jst.JSONNumber(help="The width of the symbol's stroke.", minimum=0)
    title = jst.JSONString(help='A title for the legend. (Shows field name and its function by [...]')
    titleColor = jst.JSONString(help='Optional mark property definitions for custom legend styling. [...]')
    titleFont = jst.JSONString(help='The font of the legend title.')
    titleFontSize = jst.JSONNumber(help='The font size of the legend title.')
    titleFontWeight = jst.JSONString(help='The font weight of the legend title.')
    values = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))], help='Explicitly set the visible legend values.')

    def __init__(self, format=jst.undefined, gradientHeight=jst.undefined, gradientStrokeColor=jst.undefined, gradientStrokeWidth=jst.undefined, gradientWidth=jst.undefined, labelAlign=jst.undefined, labelBaseline=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelOffset=jst.undefined, margin=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, properties=jst.undefined, shortTimeLabels=jst.undefined, symbolColor=jst.undefined, symbolShape=jst.undefined, symbolSize=jst.undefined, symbolStrokeWidth=jst.undefined, title=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, values=jst.undefined, **kwargs):
        kwds = dict(format=format, gradientHeight=gradientHeight, gradientStrokeColor=gradientStrokeColor, gradientStrokeWidth=gradientStrokeWidth, gradientWidth=gradientWidth, labelAlign=labelAlign, labelBaseline=labelBaseline, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelOffset=labelOffset, margin=margin, offset=offset, orient=orient, padding=padding, properties=properties, shortTimeLabels=shortTimeLabels, symbolColor=symbolColor, symbolShape=symbolShape, symbolSize=symbolSize, symbolStrokeWidth=symbolStrokeWidth, title=title, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, values=values)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Legend, self).__init__(**kwargs)


class LegendConfig(jst.JSONHasTraits):
    """LegendConfig class

    

    Attributes
    ----------
    gradientHeight : number
        The height of the gradient, in pixels.
    gradientStrokeColor : string
        The color of the gradient stroke, can be in hex color code or
        regular color name.
    gradientStrokeWidth : number
        The width of the gradient stroke, in pixels.
    gradientWidth : number
        The width of the gradient, in pixels.
    labelAlign : string
        The alignment of the legend label, can be left, middle or
        right.
    labelBaseline : string
        The position of the baseline of legend label, can be top,
        middle or bottom.
    labelColor : string
        The color of the legend label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the legend label.
    labelFontSize : number
        The font size of legend label.
    labelOffset : number
        The offset of the legend label.
    margin : number
        The margin around the legend, in pixels
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
    orient : string
        The orientation of the legend. One of "left" or "right". This
        determines how the legend is positioned within the scene. The
        default is "right".
    padding : number
        The padding, in pixels, between the legend and axis.
    properties : Mapping
        Optional mark property definitions for custom legend styling.
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
    symbolColor : string
        The color of the legend symbol,
    symbolShape : string
        The shape of the legend symbol, can be the 'circle', 'square',
        'cross', 'diamond',
        'triangle-up', 'triangle-down', or else a custom SVG path
        string.
    symbolSize : number
        The size of the legend symbol, in pixels.
    symbolStrokeWidth : number
        The width of the symbol's stroke.
    titleColor : string
        Optional mark property definitions for custom legend styling.
        The color of the legend title, can be in hex color code or
        regular color name.
    titleFont : string
        The font of the legend title.
    titleFontSize : number
        The font size of the legend title.
    titleFontWeight : string
        The font weight of the legend title.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    gradientHeight = jst.JSONNumber(help='The height of the gradient, in pixels.')
    gradientStrokeColor = jst.JSONString(help='The color of the gradient stroke, can be in hex color code or [...]')
    gradientStrokeWidth = jst.JSONNumber(help='The width of the gradient stroke, in pixels.')
    gradientWidth = jst.JSONNumber(help='The width of the gradient, in pixels.')
    labelAlign = jst.JSONString(help='The alignment of the legend label, can be left, middle or right.')
    labelBaseline = jst.JSONString(help='The position of the baseline of legend label, can be top, middle [...]')
    labelColor = jst.JSONString(help='The color of the legend label, can be in hex color code or [...]')
    labelFont = jst.JSONString(help='The font of the legend label.')
    labelFontSize = jst.JSONNumber(help='The font size of legend label.')
    labelOffset = jst.JSONNumber(help='The offset of the legend label.')
    margin = jst.JSONNumber(help='The margin around the legend, in pixels')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = jst.JSONString(help='The orientation of the legend. One of "left" or "right". This [...]')
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    properties = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='Optional mark property definitions for custom legend styling.')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated.')
    symbolColor = jst.JSONString(help='The color of the legend symbol,')
    symbolShape = jst.JSONString(help="The shape of the legend symbol, can be the 'circle', 'square', [...]")
    symbolSize = jst.JSONNumber(help='The size of the legend symbol, in pixels.')
    symbolStrokeWidth = jst.JSONNumber(help="The width of the symbol's stroke.", minimum=0)
    titleColor = jst.JSONString(help='Optional mark property definitions for custom legend styling. [...]')
    titleFont = jst.JSONString(help='The font of the legend title.')
    titleFontSize = jst.JSONNumber(help='The font size of the legend title.')
    titleFontWeight = jst.JSONString(help='The font weight of the legend title.')

    def __init__(self, gradientHeight=jst.undefined, gradientStrokeColor=jst.undefined, gradientStrokeWidth=jst.undefined, gradientWidth=jst.undefined, labelAlign=jst.undefined, labelBaseline=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelOffset=jst.undefined, margin=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, properties=jst.undefined, shortTimeLabels=jst.undefined, symbolColor=jst.undefined, symbolShape=jst.undefined, symbolSize=jst.undefined, symbolStrokeWidth=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, **kwargs):
        kwds = dict(gradientHeight=gradientHeight, gradientStrokeColor=gradientStrokeColor, gradientStrokeWidth=gradientStrokeWidth, gradientWidth=gradientWidth, labelAlign=labelAlign, labelBaseline=labelBaseline, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelOffset=labelOffset, margin=margin, offset=offset, orient=orient, padding=padding, properties=properties, shortTimeLabels=shortTimeLabels, symbolColor=symbolColor, symbolShape=symbolShape, symbolSize=symbolSize, symbolStrokeWidth=symbolStrokeWidth, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LegendConfig, self).__init__(**kwargs)


class MarkConfig(jst.JSONHasTraits):
    """MarkConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of left, right,
        center.
    angle : number
        The rotation angle of the text, in degrees.
    applyColorToBackground : boolean
        Apply color field to background color instead of the text.
    barSize : number
        The size of the bars.  If unspecified, the default size is
        `bandSize-1`,
        which provides 1 pixel offset between bars.
    barThinSize : number
        The size of the bars on continuous scales.
    baseline : string
        The vertical alignment of the text. One of top, middle,
        bottom.
    color : string
        Default color.
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        angle property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        angle property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
    fillOpacity : number
        
    filled : boolean
        Whether the shape\'s color should be used as fill color
        instead of stroke color.
        This is only applicable for "bar", "point", and "area".
        All marks except "point" marks are filled by default.
        See Mark Documentation (http://vega.github.io/vega-
        lite/docs/marks.html)
        for usage example.
    font : string
        The typeface to set the text in (e.g., Helvetica Neue).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., italic).
    fontWeight : string
        The font weight (e.g., bold).
    format : string
        The formatting pattern for text value. If not defined, this
        will be determined automatically.
    interpolate : string
        The line interpolation method to use. One of linear, step-
        before, step-after, basis, basis-open, cardinal, cardinal-
        open, monotone.
    lineSize : number
        Size of line mark.
    opacity : number
        
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the x and y properties.
    ruleSize : number
        Size of rule mark.
    shape : AnyOf([string, string])
        The symbol shape to use. One of circle (default), square,
        cross, diamond, triangle-up, or triangle-down, or a custom SVG
        path.
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
    size : number
        The pixel area each the point. For example: in the case of
        circles, the radius is determined in part by the square root
        of the size value.
    stacked : string
        
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        
    strokeWidth : number
        
    tension : number
        Depending on the interpolation type, sets the tension
        parameter.
    text : string
        Placeholder Text
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the x and y properties. Values for theta
        follow the same convention of arc mark startAngle and endAngle
        properties: angles are measured in radians, with 0 indicating
        "north".
    tickSize : number
        The width of the ticks.
    tickThickness : number
        Thickness of the tick mark.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.')
    applyColorToBackground = jst.JSONBoolean(help='Apply color field to background color instead of the text.')
    barSize = jst.JSONNumber(help='The size of the bars. If unspecified, the default size is [...]')
    barThinSize = jst.JSONNumber(help='The size of the bars on continuous scales.')
    baseline = VerticalAlign()
    color = jst.JSONString(help='Default color.')
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color')
    fillOpacity = jst.JSONNumber(maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the shape\\'s color should be used as fill color instead [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., Helvetica Neue).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.')
    fontStyle = FontStyle()
    fontWeight = FontWeight()
    format = jst.JSONString(help='The formatting pattern for text value. If not defined, this will [...]')
    interpolate = Interpolate()
    lineSize = jst.JSONNumber(help='Size of line mark.')
    opacity = jst.JSONNumber(maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]')
    ruleSize = jst.JSONNumber(help='Size of rule mark.')
    shape = jst.JSONAnyOf([Shape(), jst.JSONString()], help='The symbol shape to use. One of circle (default), square, cross, [...]')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated.')
    size = jst.JSONNumber(help='The pixel area each the point. For example: in the case of [...]')
    stacked = StackOffset()
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than config.color')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter.')
    text = jst.JSONString(help='Placeholder Text')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')
    tickSize = jst.JSONNumber(help='The width of the ticks.')
    tickThickness = jst.JSONNumber(help='Thickness of the tick mark.')

    def __init__(self, align=jst.undefined, angle=jst.undefined, applyColorToBackground=jst.undefined, barSize=jst.undefined, barThinSize=jst.undefined, baseline=jst.undefined, color=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, format=jst.undefined, interpolate=jst.undefined, lineSize=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, ruleSize=jst.undefined, shape=jst.undefined, shortTimeLabels=jst.undefined, size=jst.undefined, stacked=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, tickSize=jst.undefined, tickThickness=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, applyColorToBackground=applyColorToBackground, barSize=barSize, barThinSize=barThinSize, baseline=baseline, color=color, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, format=format, interpolate=interpolate, lineSize=lineSize, opacity=opacity, orient=orient, radius=radius, ruleSize=ruleSize, shape=shape, shortTimeLabels=shortTimeLabels, size=size, stacked=stacked, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta, tickSize=tickSize, tickThickness=tickThickness)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MarkConfig, self).__init__(**kwargs)


class OneOfFilter(jst.JSONHasTraits):
    """OneOfFilter class

    

    Attributes
    ----------
    field : string
        Field to be filtered
    oneOf : Array(AnyOf([string, number, boolean, DateTime]))
        A set of values that the `field`'s value should be a member
        of,
        for a data item included in the filtered data.
    timeUnit : string
        time unit for the field to be filtered.
    """
    _additional_traits = True
    _required_traits = ['field', 'oneOf']
    _trait_name_map = {}
    field = jst.JSONString(help='Field to be filtered')
    oneOf = jst.JSONArray(jst.JSONAnyOf([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean(), jst.JSONInstance(_localname('DateTime'))]), help="A set of values that the `field`'s value should be a member of, [...]")
    timeUnit = TimeUnit()

    def __init__(self, field=jst.undefined, oneOf=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(field=field, oneOf=oneOf, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OneOfFilter, self).__init__(**kwargs)


class OrderChannelDef(jst.JSONHasTraits):
    """OrderChannelDef class

    

    Attributes
    ----------
    aggregate : string
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : string
        Name of the field from which to pull a data value.
    sort : string
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
    title : string
        Title for axis or legend.
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case insensitive.
    value : ['number', 'string', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    aggregate = AggregateOp()
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONString(help='Name of the field from which to pull a data value.')
    sort = SortOrder()
    timeUnit = TimeUnit()
    title = jst.JSONString(help='Title for axis or legend.')
    type = Type()
    value = jst.JSONUnion([jst.JSONNumber(), jst.JSONString(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, title=jst.undefined, type=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, sort=sort, timeUnit=timeUnit, title=title, type=type, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OrderChannelDef, self).__init__(**kwargs)


class OverlayConfig(jst.JSONHasTraits):
    """OverlayConfig class

    

    Attributes
    ----------
    area : string
        Type of overlay for area mark (line or linepoint)
    line : boolean
        Whether to overlay line with point.
    lineStyle : MarkConfig
        Default style for the overlayed point.
    pointStyle : MarkConfig
        Default style for the overlayed point.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    area = AreaOverlay()
    line = jst.JSONBoolean(help='Whether to overlay line with point.')
    lineStyle = jst.JSONInstance(_localname('MarkConfig'), help='Default style for the overlayed point.')
    pointStyle = jst.JSONInstance(_localname('MarkConfig'), help='Default style for the overlayed point.')

    def __init__(self, area=jst.undefined, line=jst.undefined, lineStyle=jst.undefined, pointStyle=jst.undefined, **kwargs):
        kwds = dict(area=area, line=line, lineStyle=lineStyle, pointStyle=pointStyle)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OverlayConfig, self).__init__(**kwargs)


class PositionChannelDef(jst.JSONHasTraits):
    """PositionChannelDef class

    

    Attributes
    ----------
    aggregate : string
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
    axis : AnyOf([boolean, Axis])
        
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : string
        Name of the field from which to pull a data value.
    scale : Scale
        
    sort : AnyOf([SortField, string])
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
    title : string
        Title for axis or legend.
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case insensitive.
    value : ['number', 'string', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    aggregate = AggregateOp()
    axis = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Axis'))])
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONString(help='Name of the field from which to pull a data value.')
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), SortOrder()])
    timeUnit = TimeUnit()
    title = jst.JSONString(help='Title for axis or legend.')
    type = Type()
    value = jst.JSONUnion([jst.JSONNumber(), jst.JSONString(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, aggregate=jst.undefined, axis=jst.undefined, bin=jst.undefined, field=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, title=jst.undefined, type=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, axis=axis, bin=bin, field=field, scale=scale, sort=sort, timeUnit=timeUnit, title=title, type=type, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(PositionChannelDef, self).__init__(**kwargs)


class RangeFilter(jst.JSONHasTraits):
    """RangeFilter class

    

    Attributes
    ----------
    field : string
        Field to be filtered
    range : Array(AnyOf([number, DateTime]))
        Array of inclusive minimum and maximum values
        for a field value of a data item to be included in the
        filtered data.
    timeUnit : string
        time unit for the field to be filtered.
    """
    _additional_traits = True
    _required_traits = ['field', 'range']
    _trait_name_map = {}
    field = jst.JSONString(help='Field to be filtered')
    range = jst.JSONArray(jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(_localname('DateTime'))]), help='Array of inclusive minimum and maximum values for a field value [...]', maxlen=2, minlen=2)
    timeUnit = TimeUnit()

    def __init__(self, field=jst.undefined, range=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(field=field, range=range, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(RangeFilter, self).__init__(**kwargs)


class Scale(jst.JSONHasTraits):
    """Scale class

    

    Attributes
    ----------
    bandSize : AnyOf([number, string])
        
    clamp : boolean
        If true, values that exceed the data domain are clamped to
        either the minimum or maximum range value
    domain : AnyOf([Array(number), Array(string), Array(DateTime)])
        The domain of the scale, representing the set of data values.
        For quantitative data, this can take the form of a two-element
        array with minimum and maximum values. For ordinal/categorical
        data, this may be an array of valid input values.
    exponent : number
        Sets the exponent of the scale transformation. For pow scale
        types only, otherwise ignored.
    nice : AnyOf([boolean, string])
        If specified, modifies the scale domain to use a more human-
        friendly value range. If specified as a true boolean, modifies
        the scale domain to use a more human-friendly number range
        (e.g., 7 instead of 6.96). If specified as a string, modifies
        the scale domain to use a more human-friendly value range. For
        time and utc scale types only, the nice value should be a
        string indicating the desired time interval.
    padding : number
        Applies spacing among ordinal elements in the scale range. The
        actual effect depends on how the scale is configured. If the
        __points__ parameter is `true`, the padding value is
        interpreted as a multiple of the spacing between points. A
        reasonable value is 1.0, such that the first and last point
        will be offset from the minimum and maximum value by half the
        distance between points. Otherwise, padding is typically in
        the range [0, 1] and corresponds to the fraction of space in
        the range interval to allocate to padding. A value of 0.5
        means that the range band width will be equal to the padding
        width. For more, see the [D3 ordinal scale
        documentation](https://github.com/mbostock/d3/wiki/Ordinal-
        Scales).
    range : AnyOf([string, Array(number), Array(string)])
        The range of the scale, representing the set of visual values.
        For numeric values, the range can take the form of a two-
        element array with minimum and maximum values. For ordinal or
        quantized data, the range may by an array of desired output
        values, which are mapped to elements in the specified domain.
        For ordinal scales only, the range can be defined using a
        DataRef: the range values are then drawn dynamically from a
        backing data set.
    round : boolean
        If true, rounds numeric output values to integers. This can be
        helpful for snapping to the pixel grid.
    type : string
        
    useRawDomain : boolean
        Uses the source data range as scale domain instead of
        aggregated data for aggregate axis.
        This property only works with aggregate functions that produce
        values within the raw data domain (`"mean"`, `"average"`,
        `"stdev"`, `"stdevp"`, `"median"`, `"q1"`, `"q3"`, `"min"`,
        `"max"`). For other aggregations that produce values outside
        of the raw data domain (e.g. `"count"`, `"sum"`), this
        property is ignored.
    zero : boolean
        If `true`, ensures that a zero baseline value is included in
        the scale domain.
        Default value: `true` for `x` and `y` channel if the
        quantitative field is not binned
        and no custom `domain` is provided; `false` otherwise.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    bandSize = jst.JSONAnyOf([jst.JSONNumber(), BandSize()])
    clamp = jst.JSONBoolean(help='If true, values that exceed the data domain are clamped to [...]')
    domain = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))], help='The domain of the scale, representing the set of data values. [...]')
    exponent = jst.JSONNumber(help='Sets the exponent of the scale transformation. For pow scale [...]')
    nice = jst.JSONAnyOf([jst.JSONBoolean(), NiceTime()], help='If specified, modifies the scale domain to use a more human- [...]')
    padding = jst.JSONNumber(help='Applies spacing among ordinal elements in the scale range. The [...]')
    range = jst.JSONAnyOf([jst.JSONString(), jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString())], help='The range of the scale, representing the set of visual values. [...]')
    round = jst.JSONBoolean(help='If true, rounds numeric output values to integers. This can be [...]')
    type = ScaleType()
    useRawDomain = jst.JSONBoolean(help='Uses the source data range as scale domain instead of aggregated [...]')
    zero = jst.JSONBoolean(help='If `true`, ensures that a zero baseline value is included in the [...]')

    def __init__(self, bandSize=jst.undefined, clamp=jst.undefined, domain=jst.undefined, exponent=jst.undefined, nice=jst.undefined, padding=jst.undefined, range=jst.undefined, round=jst.undefined, type=jst.undefined, useRawDomain=jst.undefined, zero=jst.undefined, **kwargs):
        kwds = dict(bandSize=bandSize, clamp=clamp, domain=domain, exponent=exponent, nice=nice, padding=padding, range=range, round=round, type=type, useRawDomain=useRawDomain, zero=zero)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Scale, self).__init__(**kwargs)


class ScaleConfig(jst.JSONHasTraits):
    """ScaleConfig class

    

    Attributes
    ----------
    bandSize : AnyOf([number, string])
        Default band size for (1) `y` ordinal scale,
        and (2) `x` ordinal scale when the mark is not `text`.
    barSizeRange : Array(number)
        Default range for bar size scale
    fontSizeRange : Array(number)
        Default range for font size scale
    nominalColorRange : AnyOf([string, Array(string)])
        Default range for nominal color scale
    opacity : Array(number)
        Default range for opacity.
    padding : number
        Default padding for `x` and `y` ordinal scales.
    pointSizeRange : Array(number)
        Default range for bar size scale
    round : boolean
        If true, rounds numeric output values to integers.
        This can be helpful for snapping to the pixel grid.
        (Only available for `x`, `y`, `size`, `row`, and `column`
        scales.)
    ruleSizeRange : Array(number)
        Default range for rule stroke widths
    sequentialColorRange : AnyOf([string, Array(string)])
        Default range for ordinal / continuous color scale
    shapeRange : AnyOf([string, Array(string)])
        Default range for shape
    textBandWidth : number
        Default band width for `x` ordinal scale when is mark is
        `text`.
    tickSizeRange : Array(number)
        Default range for tick spans
    useRawDomain : boolean
        Uses the source data range as scale domain instead of
        aggregated data for aggregate axis.
        This property only works with aggregate functions that produce
        values within the raw data domain (`"mean"`, `"average"`,
        `"stdev"`, `"stdevp"`, `"median"`, `"q1"`, `"q3"`, `"min"`,
        `"max"`). For other aggregations that produce values outside
        of the raw data domain (e.g. `"count"`, `"sum"`), this
        property is ignored.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    bandSize = jst.JSONAnyOf([jst.JSONNumber(), BandSize()], help='Default band size for (1) `y` ordinal scale, and (2) `x` ordinal [...]')
    barSizeRange = jst.JSONArray(jst.JSONNumber(), help='Default range for bar size scale')
    fontSizeRange = jst.JSONArray(jst.JSONNumber(), help='Default range for font size scale')
    nominalColorRange = jst.JSONAnyOf([jst.JSONString(), jst.JSONArray(jst.JSONString())], help='Default range for nominal color scale')
    opacity = jst.JSONArray(jst.JSONNumber(), help='Default range for opacity.')
    padding = jst.JSONNumber(help='Default padding for `x` and `y` ordinal scales.')
    pointSizeRange = jst.JSONArray(jst.JSONNumber(), help='Default range for bar size scale')
    round = jst.JSONBoolean(help='If true, rounds numeric output values to integers. This can be [...]')
    ruleSizeRange = jst.JSONArray(jst.JSONNumber(), help='Default range for rule stroke widths')
    sequentialColorRange = jst.JSONAnyOf([jst.JSONString(), jst.JSONArray(jst.JSONString())], help='Default range for ordinal / continuous color scale')
    shapeRange = jst.JSONAnyOf([jst.JSONString(), jst.JSONArray(jst.JSONString())], help='Default range for shape')
    textBandWidth = jst.JSONNumber(help='Default band width for `x` ordinal scale when is mark is `text`.', minimum=0)
    tickSizeRange = jst.JSONArray(jst.JSONNumber(), help='Default range for tick spans')
    useRawDomain = jst.JSONBoolean(help='Uses the source data range as scale domain instead of aggregated [...]')

    def __init__(self, bandSize=jst.undefined, barSizeRange=jst.undefined, fontSizeRange=jst.undefined, nominalColorRange=jst.undefined, opacity=jst.undefined, padding=jst.undefined, pointSizeRange=jst.undefined, round=jst.undefined, ruleSizeRange=jst.undefined, sequentialColorRange=jst.undefined, shapeRange=jst.undefined, textBandWidth=jst.undefined, tickSizeRange=jst.undefined, useRawDomain=jst.undefined, **kwargs):
        kwds = dict(bandSize=bandSize, barSizeRange=barSizeRange, fontSizeRange=fontSizeRange, nominalColorRange=nominalColorRange, opacity=opacity, padding=padding, pointSizeRange=pointSizeRange, round=round, ruleSizeRange=ruleSizeRange, sequentialColorRange=sequentialColorRange, shapeRange=shapeRange, textBandWidth=textBandWidth, tickSizeRange=tickSizeRange, useRawDomain=useRawDomain)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ScaleConfig, self).__init__(**kwargs)


class SortField(jst.JSONHasTraits):
    """SortField class

    

    Attributes
    ----------
    field : string
        The field name to aggregate over.
    op : string
        The sort aggregation operator
    order : string
        
    """
    _additional_traits = True
    _required_traits = ['field', 'op']
    _trait_name_map = {}
    field = jst.JSONString(help='The field name to aggregate over.')
    op = AggregateOp()
    order = SortOrder()

    def __init__(self, field=jst.undefined, op=jst.undefined, order=jst.undefined, **kwargs):
        kwds = dict(field=field, op=op, order=order)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SortField, self).__init__(**kwargs)


class Transform(jst.JSONHasTraits):
    """Transform class

    

    Attributes
    ----------
    calculate : Array(Formula)
        Calculate new field(s) using the provided expresssion(s).
        Calculation are applied before filter.
    filter : AnyOf([string, EqualFilter, RangeFilter, OneOfFilter, Array(AnyOf([string, EqualFilter, RangeFilter, OneOfFilter]))])
        A string containing the filter Vega expression. Use `datum` to
        refer to the current data object.
    filterInvalid : boolean
        Whether to filter invalid values (`null` and `NaN`) from the
        data. By default (`undefined`), only quantitative and temporal
        fields are filtered. If set to `true`, all data items with
        null values are filtered. If `false`, all data items are
        included.
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    calculate = jst.JSONArray(jst.JSONInstance(_localname('Formula')), help='Calculate new field(s) using the provided expresssion(s). [...]')
    filter = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter')), jst.JSONArray(jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter'))]))], help='A string containing the filter Vega expression. Use `datum` to [...]')
    filterInvalid = jst.JSONBoolean(help='Whether to filter invalid values (`null` and `NaN`) from the [...]')

    def __init__(self, calculate=jst.undefined, filter=jst.undefined, filterInvalid=jst.undefined, **kwargs):
        kwds = dict(calculate=calculate, filter=filter, filterInvalid=filterInvalid)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Transform, self).__init__(**kwargs)


class UnitEncoding(jst.JSONHasTraits):
    """UnitEncoding class

    

    Attributes
    ----------
    color : ChannelDefWithLegend
        Color of the marks – either fill or stroke color based on mark
        type.
        (By default, fill color for `area`, `bar`, `tick`, `text`,
        `circle`, and `square` /
        stroke color for `line` and `point`.)
    detail : AnyOf([FieldDef, Array(FieldDef)])
        Additional levels of detail for grouping data in aggregate
        views and
        in line and area marks without mapping data to a specific
        visual channel.
    label : FieldDef
        
    opacity : ChannelDefWithLegend
        Opacity of the marks – either can be a value or in a range.
    order : AnyOf([OrderChannelDef, Array(OrderChannelDef)])
        Layer order for non-stacked marks, or stack order for stacked
        marks.
    path : AnyOf([OrderChannelDef, Array(OrderChannelDef)])
        Order of data points in line marks.
    shape : ChannelDefWithLegend
        The symbol's shape (only for `point` marks). The supported
        values are
        `"circle"` (default), `"square"`, `"cross"`, `"diamond"`,
        `"triangle-up"`,
        or `"triangle-down"`, or else a custom SVG path string.
    size : ChannelDefWithLegend
        Size of the mark.
        - For `point`, `square` and `circle`
        – the symbol size, or pixel area of the mark.
        - For `bar` and `tick` – the bar and tick's size.
        - For `text` – the text's font size.
        - Size is currently unsupported for `line` and `area`.
    text : FieldDef
        Text of the `text` mark.
    x : PositionChannelDef
        X coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    x2 : FieldDef
        X2 coordinates for ranged `bar`, `rule`, `area`
    y : PositionChannelDef
        Y coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    y2 : FieldDef
        Y2 coordinates for ranged `bar`, `rule`, `area`
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Color of the marks – either fill or stroke color based on mark [...]')
    detail = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONArray(jst.JSONInstance(_localname('FieldDef')))], help='Additional levels of detail for grouping data in aggregate views [...]')
    label = jst.JSONInstance(_localname('FieldDef'))
    opacity = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Opacity of the marks – either can be a value or in a range.')
    order = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderChannelDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderChannelDef')))], help='Layer order for non-stacked marks, or stack order for stacked marks.')
    path = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderChannelDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderChannelDef')))], help='Order of data points in line marks.')
    shape = jst.JSONInstance(_localname('ChannelDefWithLegend'), help="The symbol's shape (only for `point` marks). The supported [...]")
    size = jst.JSONInstance(_localname('ChannelDefWithLegend'), help='Size of the mark. - For `point`, `square` and `circle` – the [...]')
    text = jst.JSONInstance(_localname('FieldDef'), help='Text of the `text` mark.')
    x = jst.JSONInstance(_localname('PositionChannelDef'), help='X coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    x2 = jst.JSONInstance(_localname('FieldDef'), help='X2 coordinates for ranged `bar`, `rule`, `area`')
    y = jst.JSONInstance(_localname('PositionChannelDef'), help='Y coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    y2 = jst.JSONInstance(_localname('FieldDef'), help='Y2 coordinates for ranged `bar`, `rule`, `area`')

    def __init__(self, color=jst.undefined, detail=jst.undefined, label=jst.undefined, opacity=jst.undefined, order=jst.undefined, path=jst.undefined, shape=jst.undefined, size=jst.undefined, text=jst.undefined, x=jst.undefined, x2=jst.undefined, y=jst.undefined, y2=jst.undefined, **kwargs):
        kwds = dict(color=color, detail=detail, label=label, opacity=opacity, order=order, path=path, shape=shape, size=size, text=text, x=x, x2=x2, y=y, y2=y2)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(UnitEncoding, self).__init__(**kwargs)


class UnitSpec(jst.JSONHasTraits):
    """UnitSpec class

    

    Attributes
    ----------
    config : Config
        Configuration object
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
        This property has no effect on the output visualization.
    encoding : UnitEncoding
        A key-value mapping between encoding channels and definition
        of fields.
    height : number
        
    mark : string
        The mark type.
        One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`.
    name : string
        Name of the visualization for later reference.
    transform : Transform
        An object describing filter and new field calculation.
    width : number
        
    """
    _additional_traits = True
    _required_traits = ['mark']
    _trait_name_map = {}
    config = jst.JSONInstance(_localname('Config'), help='Configuration object')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose. [...]')
    encoding = jst.JSONInstance(_localname('UnitEncoding'), help='A key-value mapping between encoding channels and definition of [...]')
    height = jst.JSONNumber()
    mark = Mark()
    name = jst.JSONString(help='Name of the visualization for later reference.')
    transform = jst.JSONInstance(_localname('Transform'), help='An object describing filter and new field calculation.')
    width = jst.JSONNumber()

    def __init__(self, config=jst.undefined, data=jst.undefined, description=jst.undefined, encoding=jst.undefined, height=jst.undefined, mark=jst.undefined, name=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(config=config, data=data, description=description, encoding=encoding, height=height, mark=mark, name=name, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(UnitSpec, self).__init__(**kwargs)
